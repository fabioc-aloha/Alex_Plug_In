"use strict";var si=Object.create;var Pe=Object.defineProperty;var ai=Object.getOwnPropertyDescriptor;var ci=Object.getOwnPropertyNames;var ui=Object.getPrototypeOf,li=Object.prototype.hasOwnProperty;var x=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),di=(e,t)=>{for(var n in t)Pe(e,n,{get:t[n],enumerable:!0})},nt=(e,t,n,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of ci(t))!li.call(e,r)&&r!==n&&Pe(e,r,{get:()=>t[r],enumerable:!(i=ai(t,r))||i.enumerable});return e};var Z=(e,t,n)=>(n=e!=null?si(ui(e)):{},nt(t||!e||!e.__esModule?Pe(n,"default",{value:e,enumerable:!0}):n,e)),fi=e=>nt(Pe({},"__esModule",{value:!0}),e);var U=x(Ue=>{"use strict";Ue.fromCallback=function(e){return Object.defineProperty(function(...t){if(typeof t[t.length-1]=="function")e.apply(this,t);else return new Promise((n,i)=>{t.push((r,o)=>r!=null?i(r):n(o)),e.apply(this,t)})},"name",{value:e.name})};Ue.fromPromise=function(e){return Object.defineProperty(function(...t){let n=t[t.length-1];if(typeof n!="function")return e.apply(this,t);t.pop(),e.apply(this,t).then(i=>n(null,i),n)},"name",{value:e.name})}});var rt=x((Co,it)=>{var se=require("constants"),mi=process.cwd,$e=null,pi=process.env.GRACEFUL_FS_PLATFORM||process.platform;process.cwd=function(){return $e||($e=mi.call(process)),$e};try{process.cwd()}catch{}typeof process.chdir=="function"&&(_e=process.chdir,process.chdir=function(e){$e=null,_e.call(process,e)},Object.setPrototypeOf&&Object.setPrototypeOf(process.chdir,_e));var _e;it.exports=hi;function hi(e){se.hasOwnProperty("O_SYMLINK")&&process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)&&t(e),e.lutimes||n(e),e.chown=o(e.chown),e.fchown=o(e.fchown),e.lchown=o(e.lchown),e.chmod=i(e.chmod),e.fchmod=i(e.fchmod),e.lchmod=i(e.lchmod),e.chownSync=s(e.chownSync),e.fchownSync=s(e.fchownSync),e.lchownSync=s(e.lchownSync),e.chmodSync=r(e.chmodSync),e.fchmodSync=r(e.fchmodSync),e.lchmodSync=r(e.lchmodSync),e.stat=l(e.stat),e.fstat=l(e.fstat),e.lstat=l(e.lstat),e.statSync=v(e.statSync),e.fstatSync=v(e.fstatSync),e.lstatSync=v(e.lstatSync),e.chmod&&!e.lchmod&&(e.lchmod=function(a,c,y){y&&process.nextTick(y)},e.lchmodSync=function(){}),e.chown&&!e.lchown&&(e.lchown=function(a,c,y,h){h&&process.nextTick(h)},e.lchownSync=function(){}),pi==="win32"&&(e.rename=typeof e.rename!="function"?e.rename:(function(a){function c(y,h,m){var E=Date.now(),F=0;a(y,h,function p(q){if(q&&(q.code==="EACCES"||q.code==="EPERM"||q.code==="EBUSY")&&Date.now()-E<6e4){setTimeout(function(){e.stat(h,function(A,L){A&&A.code==="ENOENT"?a(y,h,p):m(q)})},F),F<100&&(F+=10);return}m&&m(q)})}return Object.setPrototypeOf&&Object.setPrototypeOf(c,a),c})(e.rename)),e.read=typeof e.read!="function"?e.read:(function(a){function c(y,h,m,E,F,p){var q;if(p&&typeof p=="function"){var A=0;q=function(L,B,ne){if(L&&L.code==="EAGAIN"&&A<10)return A++,a.call(e,y,h,m,E,F,q);p.apply(this,arguments)}}return a.call(e,y,h,m,E,F,q)}return Object.setPrototypeOf&&Object.setPrototypeOf(c,a),c})(e.read),e.readSync=typeof e.readSync!="function"?e.readSync:(function(a){return function(c,y,h,m,E){for(var F=0;;)try{return a.call(e,c,y,h,m,E)}catch(p){if(p.code==="EAGAIN"&&F<10){F++;continue}throw p}}})(e.readSync);function t(a){a.lchmod=function(c,y,h){a.open(c,se.O_WRONLY|se.O_SYMLINK,y,function(m,E){if(m){h&&h(m);return}a.fchmod(E,y,function(F){a.close(E,function(p){h&&h(F||p)})})})},a.lchmodSync=function(c,y){var h=a.openSync(c,se.O_WRONLY|se.O_SYMLINK,y),m=!0,E;try{E=a.fchmodSync(h,y),m=!1}finally{if(m)try{a.closeSync(h)}catch{}else a.closeSync(h)}return E}}function n(a){se.hasOwnProperty("O_SYMLINK")&&a.futimes?(a.lutimes=function(c,y,h,m){a.open(c,se.O_SYMLINK,function(E,F){if(E){m&&m(E);return}a.futimes(F,y,h,function(p){a.close(F,function(q){m&&m(p||q)})})})},a.lutimesSync=function(c,y,h){var m=a.openSync(c,se.O_SYMLINK),E,F=!0;try{E=a.futimesSync(m,y,h),F=!1}finally{if(F)try{a.closeSync(m)}catch{}else a.closeSync(m)}return E}):a.futimes&&(a.lutimes=function(c,y,h,m){m&&process.nextTick(m)},a.lutimesSync=function(){})}function i(a){return a&&function(c,y,h){return a.call(e,c,y,function(m){d(m)&&(m=null),h&&h.apply(this,arguments)})}}function r(a){return a&&function(c,y){try{return a.call(e,c,y)}catch(h){if(!d(h))throw h}}}function o(a){return a&&function(c,y,h,m){return a.call(e,c,y,h,function(E){d(E)&&(E=null),m&&m.apply(this,arguments)})}}function s(a){return a&&function(c,y,h){try{return a.call(e,c,y,h)}catch(m){if(!d(m))throw m}}}function l(a){return a&&function(c,y,h){typeof y=="function"&&(h=y,y=null);function m(E,F){F&&(F.uid<0&&(F.uid+=4294967296),F.gid<0&&(F.gid+=4294967296)),h&&h.apply(this,arguments)}return y?a.call(e,c,y,m):a.call(e,c,m)}}function v(a){return a&&function(c,y){var h=y?a.call(e,c,y):a.call(e,c);return h&&(h.uid<0&&(h.uid+=4294967296),h.gid<0&&(h.gid+=4294967296)),h}}function d(a){if(!a||a.code==="ENOSYS")return!0;var c=!process.getuid||process.getuid()!==0;return!!(c&&(a.code==="EINVAL"||a.code==="EPERM"))}}});var at=x((Do,st)=>{var ot=require("stream").Stream;st.exports=yi;function yi(e){return{ReadStream:t,WriteStream:n};function t(i,r){if(!(this instanceof t))return new t(i,r);ot.call(this);var o=this;this.path=i,this.fd=null,this.readable=!0,this.paused=!1,this.flags="r",this.mode=438,this.bufferSize=64*1024,r=r||{};for(var s=Object.keys(r),l=0,v=s.length;l<v;l++){var d=s[l];this[d]=r[d]}if(this.encoding&&this.setEncoding(this.encoding),this.start!==void 0){if(typeof this.start!="number")throw TypeError("start must be a Number");if(this.end===void 0)this.end=1/0;else if(typeof this.end!="number")throw TypeError("end must be a Number");if(this.start>this.end)throw new Error("start must be <= end");this.pos=this.start}if(this.fd!==null){process.nextTick(function(){o._read()});return}e.open(this.path,this.flags,this.mode,function(a,c){if(a){o.emit("error",a),o.readable=!1;return}o.fd=c,o.emit("open",c),o._read()})}function n(i,r){if(!(this instanceof n))return new n(i,r);ot.call(this),this.path=i,this.fd=null,this.writable=!0,this.flags="w",this.encoding="binary",this.mode=438,this.bytesWritten=0,r=r||{};for(var o=Object.keys(r),s=0,l=o.length;s<l;s++){var v=o[s];this[v]=r[v]}if(this.start!==void 0){if(typeof this.start!="number")throw TypeError("start must be a Number");if(this.start<0)throw new Error("start must be >= zero");this.pos=this.start}this.busy=!1,this._queue=[],this.fd===null&&(this._open=e.open,this._queue.push([this._open,this.path,this.flags,this.mode,void 0]),this.flush())}}});var ut=x((Ao,ct)=>{"use strict";ct.exports=gi;var wi=Object.getPrototypeOf||function(e){return e.__proto__};function gi(e){if(e===null||typeof e!="object")return e;if(e instanceof Object)var t={__proto__:wi(e)};else var t=Object.create(null);return Object.getOwnPropertyNames(e).forEach(function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}),t}});var pe=x((To,Be)=>{var N=require("fs"),Si=rt(),vi=at(),ki=ut(),Ce=require("util"),W,Ae;typeof Symbol=="function"&&typeof Symbol.for=="function"?(W=Symbol.for("graceful-fs.queue"),Ae=Symbol.for("graceful-fs.previous")):(W="___graceful-fs.queue",Ae="___graceful-fs.previous");function xi(){}function ft(e,t){Object.defineProperty(e,W,{get:function(){return t}})}var le=xi;Ce.debuglog?le=Ce.debuglog("gfs4"):/\bgfs4\b/i.test(process.env.NODE_DEBUG||"")&&(le=function(){var e=Ce.format.apply(Ce,arguments);e="GFS4: "+e.split(/\n/).join(`
GFS4: `),console.error(e)});N[W]||(lt=global[W]||[],ft(N,lt),N.close=(function(e){function t(n,i){return e.call(N,n,function(r){r||dt(),typeof i=="function"&&i.apply(this,arguments)})}return Object.defineProperty(t,Ae,{value:e}),t})(N.close),N.closeSync=(function(e){function t(n){e.apply(N,arguments),dt()}return Object.defineProperty(t,Ae,{value:e}),t})(N.closeSync),/\bgfs4\b/i.test(process.env.NODE_DEBUG||"")&&process.on("exit",function(){le(N[W]),require("assert").equal(N[W].length,0)}));var lt;global[W]||ft(global,N[W]);Be.exports=We(ki(N));process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH&&!N.__patched&&(Be.exports=We(N),N.__patched=!0);function We(e){Si(e),e.gracefulify=We,e.createReadStream=B,e.createWriteStream=ne;var t=e.readFile;e.readFile=n;function n(w,b,f){return typeof b=="function"&&(f=b,b=null),g(w,b,f);function g(k,P,$,C){return t(k,P,function(D){D&&(D.code==="EMFILE"||D.code==="ENFILE")?me([g,[k,P,$],D,C||Date.now(),Date.now()]):typeof $=="function"&&$.apply(this,arguments)})}}var i=e.writeFile;e.writeFile=r;function r(w,b,f,g){return typeof f=="function"&&(g=f,f=null),k(w,b,f,g);function k(P,$,C,D,I){return i(P,$,C,function(T){T&&(T.code==="EMFILE"||T.code==="ENFILE")?me([k,[P,$,C,D],T,I||Date.now(),Date.now()]):typeof D=="function"&&D.apply(this,arguments)})}}var o=e.appendFile;o&&(e.appendFile=s);function s(w,b,f,g){return typeof f=="function"&&(g=f,f=null),k(w,b,f,g);function k(P,$,C,D,I){return o(P,$,C,function(T){T&&(T.code==="EMFILE"||T.code==="ENFILE")?me([k,[P,$,C,D],T,I||Date.now(),Date.now()]):typeof D=="function"&&D.apply(this,arguments)})}}var l=e.copyFile;l&&(e.copyFile=v);function v(w,b,f,g){return typeof f=="function"&&(g=f,f=0),k(w,b,f,g);function k(P,$,C,D,I){return l(P,$,C,function(T){T&&(T.code==="EMFILE"||T.code==="ENFILE")?me([k,[P,$,C,D],T,I||Date.now(),Date.now()]):typeof D=="function"&&D.apply(this,arguments)})}}var d=e.readdir;e.readdir=c;var a=/^v[0-5]\./;function c(w,b,f){typeof b=="function"&&(f=b,b=null);var g=a.test(process.version)?function($,C,D,I){return d($,k($,C,D,I))}:function($,C,D,I){return d($,C,k($,C,D,I))};return g(w,b,f);function k(P,$,C,D){return function(I,T){I&&(I.code==="EMFILE"||I.code==="ENFILE")?me([g,[P,$,C],I,D||Date.now(),Date.now()]):(T&&T.sort&&T.sort(),typeof C=="function"&&C.call(this,I,T))}}}if(process.version.substr(0,4)==="v0.8"){var y=vi(e);p=y.ReadStream,A=y.WriteStream}var h=e.ReadStream;h&&(p.prototype=Object.create(h.prototype),p.prototype.open=q);var m=e.WriteStream;m&&(A.prototype=Object.create(m.prototype),A.prototype.open=L),Object.defineProperty(e,"ReadStream",{get:function(){return p},set:function(w){p=w},enumerable:!0,configurable:!0}),Object.defineProperty(e,"WriteStream",{get:function(){return A},set:function(w){A=w},enumerable:!0,configurable:!0});var E=p;Object.defineProperty(e,"FileReadStream",{get:function(){return E},set:function(w){E=w},enumerable:!0,configurable:!0});var F=A;Object.defineProperty(e,"FileWriteStream",{get:function(){return F},set:function(w){F=w},enumerable:!0,configurable:!0});function p(w,b){return this instanceof p?(h.apply(this,arguments),this):p.apply(Object.create(p.prototype),arguments)}function q(){var w=this;Q(w.path,w.flags,w.mode,function(b,f){b?(w.autoClose&&w.destroy(),w.emit("error",b)):(w.fd=f,w.emit("open",f),w.read())})}function A(w,b){return this instanceof A?(m.apply(this,arguments),this):A.apply(Object.create(A.prototype),arguments)}function L(){var w=this;Q(w.path,w.flags,w.mode,function(b,f){b?(w.destroy(),w.emit("error",b)):(w.fd=f,w.emit("open",f))})}function B(w,b){return new e.ReadStream(w,b)}function ne(w,b){return new e.WriteStream(w,b)}var H=e.open;e.open=Q;function Q(w,b,f,g){return typeof f=="function"&&(g=f,f=null),k(w,b,f,g);function k(P,$,C,D,I){return H(P,$,C,function(T,Fe){T&&(T.code==="EMFILE"||T.code==="ENFILE")?me([k,[P,$,C,D],T,I||Date.now(),Date.now()]):typeof D=="function"&&D.apply(this,arguments)})}}return e}function me(e){le("ENQUEUE",e[0].name,e[1]),N[W].push(e),Je()}var De;function dt(){for(var e=Date.now(),t=0;t<N[W].length;++t)N[W][t].length>2&&(N[W][t][3]=e,N[W][t][4]=e);Je()}function Je(){if(clearTimeout(De),De=void 0,N[W].length!==0){var e=N[W].shift(),t=e[0],n=e[1],i=e[2],r=e[3],o=e[4];if(r===void 0)le("RETRY",t.name,n),t.apply(null,n);else if(Date.now()-r>=6e4){le("TIMEOUT",t.name,n);var s=n.pop();typeof s=="function"&&s.call(null,i)}else{var l=Date.now()-o,v=Math.max(o-r,1),d=Math.min(v*1.2,100);l>=d?(le("RETRY",t.name,n),t.apply(null,n.concat([r]))):N[W].push(e)}De===void 0&&(De=setTimeout(Je,0))}}});var z=x(re=>{"use strict";var mt=U().fromCallback,V=pe(),Ei=["access","appendFile","chmod","chown","close","copyFile","cp","fchmod","fchown","fdatasync","fstat","fsync","ftruncate","futimes","glob","lchmod","lchown","lutimes","link","lstat","mkdir","mkdtemp","open","opendir","readdir","readFile","readlink","realpath","rename","rm","rmdir","stat","statfs","symlink","truncate","unlink","utimes","writeFile"].filter(e=>typeof V[e]=="function");Object.assign(re,V);Ei.forEach(e=>{re[e]=mt(V[e])});re.exists=function(e,t){return typeof t=="function"?V.exists(e,t):new Promise(n=>V.exists(e,n))};re.read=function(e,t,n,i,r,o){return typeof o=="function"?V.read(e,t,n,i,r,o):new Promise((s,l)=>{V.read(e,t,n,i,r,(v,d,a)=>{if(v)return l(v);s({bytesRead:d,buffer:a})})})};re.write=function(e,t,...n){return typeof n[n.length-1]=="function"?V.write(e,t,...n):new Promise((i,r)=>{V.write(e,t,...n,(o,s,l)=>{if(o)return r(o);i({bytesWritten:s,buffer:l})})})};re.readv=function(e,t,...n){return typeof n[n.length-1]=="function"?V.readv(e,t,...n):new Promise((i,r)=>{V.readv(e,t,...n,(o,s,l)=>{if(o)return r(o);i({bytesRead:s,buffers:l})})})};re.writev=function(e,t,...n){return typeof n[n.length-1]=="function"?V.writev(e,t,...n):new Promise((i,r)=>{V.writev(e,t,...n,(o,s,l)=>{if(o)return r(o);i({bytesWritten:s,buffers:l})})})};typeof V.realpath.native=="function"?re.realpath.native=mt(V.realpath.native):process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?","Warning","fs-extra-WARN0003")});var ht=x((No,pt)=>{"use strict";var bi=require("path");pt.exports.checkPath=function(t){if(process.platform==="win32"&&/[<>:"|?*]/.test(t.replace(bi.parse(t).root,""))){let i=new Error(`Path contains invalid characters: ${t}`);throw i.code="EINVAL",i}}});var St=x((Oo,Ve)=>{"use strict";var yt=z(),{checkPath:wt}=ht(),gt=e=>{let t={mode:511};return typeof e=="number"?e:{...t,...e}.mode};Ve.exports.makeDir=async(e,t)=>(wt(e),yt.mkdir(e,{mode:gt(t),recursive:!0}));Ve.exports.makeDirSync=(e,t)=>(wt(e),yt.mkdirSync(e,{mode:gt(t),recursive:!0}))});var ee=x((jo,vt)=>{"use strict";var Fi=U().fromPromise,{makeDir:Pi,makeDirSync:ze}=St(),Ge=Fi(Pi);vt.exports={mkdirs:Ge,mkdirsSync:ze,mkdirp:Ge,mkdirpSync:ze,ensureDir:Ge,ensureDirSync:ze}});var ae=x((Ro,xt)=>{"use strict";var $i=U().fromPromise,kt=z();function Ci(e){return kt.access(e).then(()=>!0).catch(()=>!1)}xt.exports={pathExists:$i(Ci),pathExistsSync:kt.existsSync}});var Ye=x((Io,Et)=>{"use strict";var he=z(),Di=U().fromPromise;async function Ai(e,t,n){let i=await he.open(e,"r+"),r=null;try{await he.futimes(i,t,n)}finally{try{await he.close(i)}catch(o){r=o}}if(r)throw r}function Ti(e,t,n){let i=he.openSync(e,"r+");return he.futimesSync(i,t,n),he.closeSync(i)}Et.exports={utimesMillis:Di(Ai),utimesMillisSync:Ti}});var de=x((Mo,$t)=>{"use strict";var ye=z(),_=require("path"),bt=U().fromPromise;function qi(e,t,n){let i=n.dereference?r=>ye.stat(r,{bigint:!0}):r=>ye.lstat(r,{bigint:!0});return Promise.all([i(e),i(t).catch(r=>{if(r.code==="ENOENT")return null;throw r})]).then(([r,o])=>({srcStat:r,destStat:o}))}function Ni(e,t,n){let i,r=n.dereference?s=>ye.statSync(s,{bigint:!0}):s=>ye.lstatSync(s,{bigint:!0}),o=r(e);try{i=r(t)}catch(s){if(s.code==="ENOENT")return{srcStat:o,destStat:null};throw s}return{srcStat:o,destStat:i}}async function Oi(e,t,n,i){let{srcStat:r,destStat:o}=await qi(e,t,i);if(o){if(ge(r,o)){let s=_.basename(e),l=_.basename(t);if(n==="move"&&s!==l&&s.toLowerCase()===l.toLowerCase())return{srcStat:r,destStat:o,isChangingCase:!0};throw new Error("Source and destination must not be the same.")}if(r.isDirectory()&&!o.isDirectory())throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);if(!r.isDirectory()&&o.isDirectory())throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`)}if(r.isDirectory()&&He(e,t))throw new Error(Te(e,t,n));return{srcStat:r,destStat:o}}function ji(e,t,n,i){let{srcStat:r,destStat:o}=Ni(e,t,i);if(o){if(ge(r,o)){let s=_.basename(e),l=_.basename(t);if(n==="move"&&s!==l&&s.toLowerCase()===l.toLowerCase())return{srcStat:r,destStat:o,isChangingCase:!0};throw new Error("Source and destination must not be the same.")}if(r.isDirectory()&&!o.isDirectory())throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);if(!r.isDirectory()&&o.isDirectory())throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`)}if(r.isDirectory()&&He(e,t))throw new Error(Te(e,t,n));return{srcStat:r,destStat:o}}async function Ft(e,t,n,i){let r=_.resolve(_.dirname(e)),o=_.resolve(_.dirname(n));if(o===r||o===_.parse(o).root)return;let s;try{s=await ye.stat(o,{bigint:!0})}catch(l){if(l.code==="ENOENT")return;throw l}if(ge(t,s))throw new Error(Te(e,n,i));return Ft(e,t,o,i)}function Pt(e,t,n,i){let r=_.resolve(_.dirname(e)),o=_.resolve(_.dirname(n));if(o===r||o===_.parse(o).root)return;let s;try{s=ye.statSync(o,{bigint:!0})}catch(l){if(l.code==="ENOENT")return;throw l}if(ge(t,s))throw new Error(Te(e,n,i));return Pt(e,t,o,i)}function ge(e,t){return t.ino!==void 0&&t.dev!==void 0&&t.ino===e.ino&&t.dev===e.dev}function He(e,t){let n=_.resolve(e).split(_.sep).filter(r=>r),i=_.resolve(t).split(_.sep).filter(r=>r);return n.every((r,o)=>i[o]===r)}function Te(e,t,n){return`Cannot ${n} '${e}' to a subdirectory of itself, '${t}'.`}$t.exports={checkPaths:bt(Oi),checkPathsSync:ji,checkParentPaths:bt(Ft),checkParentPathsSync:Pt,isSrcSubdir:He,areIdentical:ge}});var Dt=x((Lo,Ct)=>{"use strict";async function Ri(e,t){let n=[];for await(let i of e)n.push(t(i).then(()=>null,r=>r??new Error("unknown error")));await Promise.all(n.map(i=>i.then(r=>{if(r!==null)throw r})))}Ct.exports={asyncIteratorConcurrentProcess:Ri}});var Ot=x((Uo,Nt)=>{"use strict";var J=z(),Se=require("path"),{mkdirs:Ii}=ee(),{pathExists:Mi}=ae(),{utimesMillis:Li}=Ye(),ve=de(),{asyncIteratorConcurrentProcess:Ui}=Dt();async function _i(e,t,n={}){typeof n=="function"&&(n={filter:n}),n.clobber="clobber"in n?!!n.clobber:!0,n.overwrite="overwrite"in n?!!n.overwrite:n.clobber,n.preserveTimestamps&&process.arch==="ia32"&&process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,"Warning","fs-extra-WARN0001");let{srcStat:i,destStat:r}=await ve.checkPaths(e,t,"copy",n);if(await ve.checkParentPaths(e,i,t,"copy"),!await Tt(e,t,n))return;let s=Se.dirname(t);await Mi(s)||await Ii(s),await qt(r,e,t,n)}async function Tt(e,t,n){return n.filter?n.filter(e,t):!0}async function qt(e,t,n,i){let o=await(i.dereference?J.stat:J.lstat)(t);if(o.isDirectory())return Vi(o,e,t,n,i);if(o.isFile()||o.isCharacterDevice()||o.isBlockDevice())return Wi(o,e,t,n,i);if(o.isSymbolicLink())return zi(e,t,n,i);throw o.isSocket()?new Error(`Cannot copy a socket file: ${t}`):o.isFIFO()?new Error(`Cannot copy a FIFO pipe: ${t}`):new Error(`Unknown file: ${t}`)}async function Wi(e,t,n,i,r){if(!t)return At(e,n,i,r);if(r.overwrite)return await J.unlink(i),At(e,n,i,r);if(r.errorOnExist)throw new Error(`'${i}' already exists`)}async function At(e,t,n,i){if(await J.copyFile(t,n),i.preserveTimestamps){Ji(e.mode)&&await Bi(n,e.mode);let r=await J.stat(t);await Li(n,r.atime,r.mtime)}return J.chmod(n,e.mode)}function Ji(e){return(e&128)===0}function Bi(e,t){return J.chmod(e,t|128)}async function Vi(e,t,n,i,r){t||await J.mkdir(i),await Ui(await J.opendir(n),async o=>{let s=Se.join(n,o.name),l=Se.join(i,o.name);if(await Tt(s,l,r)){let{destStat:d}=await ve.checkPaths(s,l,"copy",r);await qt(d,s,l,r)}}),t||await J.chmod(i,e.mode)}async function zi(e,t,n,i){let r=await J.readlink(t);if(i.dereference&&(r=Se.resolve(process.cwd(),r)),!e)return J.symlink(r,n);let o=null;try{o=await J.readlink(n)}catch(s){if(s.code==="EINVAL"||s.code==="UNKNOWN")return J.symlink(r,n);throw s}if(i.dereference&&(o=Se.resolve(process.cwd(),o)),ve.isSrcSubdir(r,o))throw new Error(`Cannot copy '${r}' to a subdirectory of itself, '${o}'.`);if(ve.isSrcSubdir(o,r))throw new Error(`Cannot overwrite '${o}' with '${r}'.`);return await J.unlink(n),J.symlink(r,n)}Nt.exports=_i});var Lt=x((_o,Mt)=>{"use strict";var G=pe(),ke=require("path"),Gi=ee().mkdirsSync,Yi=Ye().utimesMillisSync,xe=de();function Hi(e,t,n){typeof n=="function"&&(n={filter:n}),n=n||{},n.clobber="clobber"in n?!!n.clobber:!0,n.overwrite="overwrite"in n?!!n.overwrite:n.clobber,n.preserveTimestamps&&process.arch==="ia32"&&process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,"Warning","fs-extra-WARN0002");let{srcStat:i,destStat:r}=xe.checkPathsSync(e,t,"copy",n);if(xe.checkParentPathsSync(e,i,t,"copy"),n.filter&&!n.filter(e,t))return;let o=ke.dirname(t);return G.existsSync(o)||Gi(o),jt(r,e,t,n)}function jt(e,t,n,i){let o=(i.dereference?G.statSync:G.lstatSync)(t);if(o.isDirectory())return nr(o,e,t,n,i);if(o.isFile()||o.isCharacterDevice()||o.isBlockDevice())return Ki(o,e,t,n,i);if(o.isSymbolicLink())return or(e,t,n,i);throw o.isSocket()?new Error(`Cannot copy a socket file: ${t}`):o.isFIFO()?new Error(`Cannot copy a FIFO pipe: ${t}`):new Error(`Unknown file: ${t}`)}function Ki(e,t,n,i,r){return t?Qi(e,n,i,r):Rt(e,n,i,r)}function Qi(e,t,n,i){if(i.overwrite)return G.unlinkSync(n),Rt(e,t,n,i);if(i.errorOnExist)throw new Error(`'${n}' already exists`)}function Rt(e,t,n,i){return G.copyFileSync(t,n),i.preserveTimestamps&&Xi(e.mode,t,n),Ke(n,e.mode)}function Xi(e,t,n){return Zi(e)&&er(n,e),tr(t,n)}function Zi(e){return(e&128)===0}function er(e,t){return Ke(e,t|128)}function Ke(e,t){return G.chmodSync(e,t)}function tr(e,t){let n=G.statSync(e);return Yi(t,n.atime,n.mtime)}function nr(e,t,n,i,r){return t?It(n,i,r):ir(e.mode,n,i,r)}function ir(e,t,n,i){return G.mkdirSync(n),It(t,n,i),Ke(n,e)}function It(e,t,n){let i=G.opendirSync(e);try{let r;for(;(r=i.readSync())!==null;)rr(r.name,e,t,n)}finally{i.closeSync()}}function rr(e,t,n,i){let r=ke.join(t,e),o=ke.join(n,e);if(i.filter&&!i.filter(r,o))return;let{destStat:s}=xe.checkPathsSync(r,o,"copy",i);return jt(s,r,o,i)}function or(e,t,n,i){let r=G.readlinkSync(t);if(i.dereference&&(r=ke.resolve(process.cwd(),r)),e){let o;try{o=G.readlinkSync(n)}catch(s){if(s.code==="EINVAL"||s.code==="UNKNOWN")return G.symlinkSync(r,n);throw s}if(i.dereference&&(o=ke.resolve(process.cwd(),o)),xe.isSrcSubdir(r,o))throw new Error(`Cannot copy '${r}' to a subdirectory of itself, '${o}'.`);if(xe.isSrcSubdir(o,r))throw new Error(`Cannot overwrite '${o}' with '${r}'.`);return sr(r,n)}else return G.symlinkSync(r,n)}function sr(e,t){return G.unlinkSync(t),G.symlinkSync(e,t)}Mt.exports=Hi});var qe=x((Wo,Ut)=>{"use strict";var ar=U().fromPromise;Ut.exports={copy:ar(Ot()),copySync:Lt()}});var Ee=x((Jo,Wt)=>{"use strict";var _t=pe(),cr=U().fromCallback;function ur(e,t){_t.rm(e,{recursive:!0,force:!0},t)}function lr(e){_t.rmSync(e,{recursive:!0,force:!0})}Wt.exports={remove:cr(ur),removeSync:lr}});var Kt=x((Bo,Ht)=>{"use strict";var dr=U().fromPromise,Vt=z(),zt=require("path"),Gt=ee(),Yt=Ee(),Jt=dr(async function(t){let n;try{n=await Vt.readdir(t)}catch{return Gt.mkdirs(t)}return Promise.all(n.map(i=>Yt.remove(zt.join(t,i))))});function Bt(e){let t;try{t=Vt.readdirSync(e)}catch{return Gt.mkdirsSync(e)}t.forEach(n=>{n=zt.join(e,n),Yt.removeSync(n)})}Ht.exports={emptyDirSync:Bt,emptydirSync:Bt,emptyDir:Jt,emptydir:Jt}});var en=x((Vo,Zt)=>{"use strict";var fr=U().fromPromise,Qt=require("path"),oe=z(),Xt=ee();async function mr(e){let t;try{t=await oe.stat(e)}catch{}if(t&&t.isFile())return;let n=Qt.dirname(e),i=null;try{i=await oe.stat(n)}catch(r){if(r.code==="ENOENT"){await Xt.mkdirs(n),await oe.writeFile(e,"");return}else throw r}i.isDirectory()?await oe.writeFile(e,""):await oe.readdir(n)}function pr(e){let t;try{t=oe.statSync(e)}catch{}if(t&&t.isFile())return;let n=Qt.dirname(e);try{oe.statSync(n).isDirectory()||oe.readdirSync(n)}catch(i){if(i&&i.code==="ENOENT")Xt.mkdirsSync(n);else throw i}oe.writeFileSync(e,"")}Zt.exports={createFile:fr(mr),createFileSync:pr}});var sn=x((zo,on)=>{"use strict";var hr=U().fromPromise,tn=require("path"),ce=z(),nn=ee(),{pathExists:yr}=ae(),{areIdentical:rn}=de();async function wr(e,t){let n;try{n=await ce.lstat(t)}catch{}let i;try{i=await ce.lstat(e)}catch(s){throw s.message=s.message.replace("lstat","ensureLink"),s}if(n&&rn(i,n))return;let r=tn.dirname(t);await yr(r)||await nn.mkdirs(r),await ce.link(e,t)}function gr(e,t){let n;try{n=ce.lstatSync(t)}catch{}try{let o=ce.lstatSync(e);if(n&&rn(o,n))return}catch(o){throw o.message=o.message.replace("lstat","ensureLink"),o}let i=tn.dirname(t);return ce.existsSync(i)||nn.mkdirsSync(i),ce.linkSync(e,t)}on.exports={createLink:hr(wr),createLinkSync:gr}});var cn=x((Go,an)=>{"use strict";var ue=require("path"),be=z(),{pathExists:Sr}=ae(),vr=U().fromPromise;async function kr(e,t){if(ue.isAbsolute(e)){try{await be.lstat(e)}catch(o){throw o.message=o.message.replace("lstat","ensureSymlink"),o}return{toCwd:e,toDst:e}}let n=ue.dirname(t),i=ue.join(n,e);if(await Sr(i))return{toCwd:i,toDst:e};try{await be.lstat(e)}catch(o){throw o.message=o.message.replace("lstat","ensureSymlink"),o}return{toCwd:e,toDst:ue.relative(n,e)}}function xr(e,t){if(ue.isAbsolute(e)){if(!be.existsSync(e))throw new Error("absolute srcpath does not exist");return{toCwd:e,toDst:e}}let n=ue.dirname(t),i=ue.join(n,e);if(be.existsSync(i))return{toCwd:i,toDst:e};if(!be.existsSync(e))throw new Error("relative srcpath does not exist");return{toCwd:e,toDst:ue.relative(n,e)}}an.exports={symlinkPaths:vr(kr),symlinkPathsSync:xr}});var dn=x((Yo,ln)=>{"use strict";var un=z(),Er=U().fromPromise;async function br(e,t){if(t)return t;let n;try{n=await un.lstat(e)}catch{return"file"}return n&&n.isDirectory()?"dir":"file"}function Fr(e,t){if(t)return t;let n;try{n=un.lstatSync(e)}catch{return"file"}return n&&n.isDirectory()?"dir":"file"}ln.exports={symlinkType:Er(br),symlinkTypeSync:Fr}});var hn=x((Ho,pn)=>{"use strict";var Pr=U().fromPromise,fn=require("path"),ie=z(),{mkdirs:$r,mkdirsSync:Cr}=ee(),{symlinkPaths:Dr,symlinkPathsSync:Ar}=cn(),{symlinkType:Tr,symlinkTypeSync:qr}=dn(),{pathExists:Nr}=ae(),{areIdentical:mn}=de();async function Or(e,t,n){let i;try{i=await ie.lstat(t)}catch{}if(i&&i.isSymbolicLink()){let[l,v]=await Promise.all([ie.stat(e),ie.stat(t)]);if(mn(l,v))return}let r=await Dr(e,t);e=r.toDst;let o=await Tr(r.toCwd,n),s=fn.dirname(t);return await Nr(s)||await $r(s),ie.symlink(e,t,o)}function jr(e,t,n){let i;try{i=ie.lstatSync(t)}catch{}if(i&&i.isSymbolicLink()){let l=ie.statSync(e),v=ie.statSync(t);if(mn(l,v))return}let r=Ar(e,t);e=r.toDst,n=qr(r.toCwd,n);let o=fn.dirname(t);return ie.existsSync(o)||Cr(o),ie.symlinkSync(e,t,n)}pn.exports={createSymlink:Pr(Or),createSymlinkSync:jr}});var En=x((Ko,xn)=>{"use strict";var{createFile:yn,createFileSync:wn}=en(),{createLink:gn,createLinkSync:Sn}=sn(),{createSymlink:vn,createSymlinkSync:kn}=hn();xn.exports={createFile:yn,createFileSync:wn,ensureFile:yn,ensureFileSync:wn,createLink:gn,createLinkSync:Sn,ensureLink:gn,ensureLinkSync:Sn,createSymlink:vn,createSymlinkSync:kn,ensureSymlink:vn,ensureSymlinkSync:kn}});var Ne=x((Qo,bn)=>{function Rr(e,{EOL:t=`
`,finalEOL:n=!0,replacer:i=null,spaces:r}={}){let o=n?t:"";return JSON.stringify(e,i,r).replace(/\n/g,t)+o}function Ir(e){return Buffer.isBuffer(e)&&(e=e.toString("utf8")),e.replace(/^\uFEFF/,"")}bn.exports={stringify:Rr,stripBom:Ir}});var Cn=x((Xo,$n)=>{var we;try{we=pe()}catch{we=require("fs")}var Oe=U(),{stringify:Fn,stripBom:Pn}=Ne();async function Mr(e,t={}){typeof t=="string"&&(t={encoding:t});let n=t.fs||we,i="throws"in t?t.throws:!0,r=await Oe.fromCallback(n.readFile)(e,t);r=Pn(r);let o;try{o=JSON.parse(r,t?t.reviver:null)}catch(s){if(i)throw s.message=`${e}: ${s.message}`,s;return null}return o}var Lr=Oe.fromPromise(Mr);function Ur(e,t={}){typeof t=="string"&&(t={encoding:t});let n=t.fs||we,i="throws"in t?t.throws:!0;try{let r=n.readFileSync(e,t);return r=Pn(r),JSON.parse(r,t.reviver)}catch(r){if(i)throw r.message=`${e}: ${r.message}`,r;return null}}async function _r(e,t,n={}){let i=n.fs||we,r=Fn(t,n);await Oe.fromCallback(i.writeFile)(e,r,n)}var Wr=Oe.fromPromise(_r);function Jr(e,t,n={}){let i=n.fs||we,r=Fn(t,n);return i.writeFileSync(e,r,n)}$n.exports={readFile:Lr,readFileSync:Ur,writeFile:Wr,writeFileSync:Jr}});var An=x((Zo,Dn)=>{"use strict";var je=Cn();Dn.exports={readJson:je.readFile,readJsonSync:je.readFileSync,writeJson:je.writeFile,writeJsonSync:je.writeFileSync}});var Re=x((es,Nn)=>{"use strict";var Br=U().fromPromise,Qe=z(),Tn=require("path"),qn=ee(),Vr=ae().pathExists;async function zr(e,t,n="utf-8"){let i=Tn.dirname(e);return await Vr(i)||await qn.mkdirs(i),Qe.writeFile(e,t,n)}function Gr(e,...t){let n=Tn.dirname(e);Qe.existsSync(n)||qn.mkdirsSync(n),Qe.writeFileSync(e,...t)}Nn.exports={outputFile:Br(zr),outputFileSync:Gr}});var jn=x((ts,On)=>{"use strict";var{stringify:Yr}=Ne(),{outputFile:Hr}=Re();async function Kr(e,t,n={}){let i=Yr(t,n);await Hr(e,i,n)}On.exports=Kr});var In=x((ns,Rn)=>{"use strict";var{stringify:Qr}=Ne(),{outputFileSync:Xr}=Re();function Zr(e,t,n){let i=Qr(t,n);Xr(e,i,n)}Rn.exports=Zr});var Ln=x((is,Mn)=>{"use strict";var eo=U().fromPromise,Y=An();Y.outputJson=eo(jn());Y.outputJsonSync=In();Y.outputJSON=Y.outputJson;Y.outputJSONSync=Y.outputJsonSync;Y.writeJSON=Y.writeJson;Y.writeJSONSync=Y.writeJsonSync;Y.readJSON=Y.readJson;Y.readJSONSync=Y.readJsonSync;Mn.exports=Y});var Bn=x((rs,Jn)=>{"use strict";var to=z(),Un=require("path"),{copy:no}=qe(),{remove:Wn}=Ee(),{mkdirp:io}=ee(),{pathExists:ro}=ae(),_n=de();async function oo(e,t,n={}){let i=n.overwrite||n.clobber||!1,{srcStat:r,isChangingCase:o=!1}=await _n.checkPaths(e,t,"move",n);await _n.checkParentPaths(e,r,t,"move");let s=Un.dirname(t);return Un.parse(s).root!==s&&await io(s),so(e,t,i,o)}async function so(e,t,n,i){if(!i){if(n)await Wn(t);else if(await ro(t))throw new Error("dest already exists.")}try{await to.rename(e,t)}catch(r){if(r.code!=="EXDEV")throw r;await ao(e,t,n)}}async function ao(e,t,n){return await no(e,t,{overwrite:n,errorOnExist:!0,preserveTimestamps:!0}),Wn(e)}Jn.exports=oo});var Hn=x((os,Yn)=>{"use strict";var zn=pe(),Ze=require("path"),co=qe().copySync,Gn=Ee().removeSync,uo=ee().mkdirpSync,Vn=de();function lo(e,t,n){n=n||{};let i=n.overwrite||n.clobber||!1,{srcStat:r,isChangingCase:o=!1}=Vn.checkPathsSync(e,t,"move",n);return Vn.checkParentPathsSync(e,r,t,"move"),fo(t)||uo(Ze.dirname(t)),mo(e,t,i,o)}function fo(e){let t=Ze.dirname(e);return Ze.parse(t).root===t}function mo(e,t,n,i){if(i)return Xe(e,t,n);if(n)return Gn(t),Xe(e,t,n);if(zn.existsSync(t))throw new Error("dest already exists.");return Xe(e,t,n)}function Xe(e,t,n){try{zn.renameSync(e,t)}catch(i){if(i.code!=="EXDEV")throw i;return po(e,t,n)}}function po(e,t,n){return co(e,t,{overwrite:n,errorOnExist:!0,preserveTimestamps:!0}),Gn(e)}Yn.exports=lo});var Qn=x((ss,Kn)=>{"use strict";var ho=U().fromPromise;Kn.exports={move:ho(Bn()),moveSync:Hn()}});var Ie=x((as,Xn)=>{"use strict";Xn.exports={...z(),...qe(),...Kt(),...En(),...Ln(),...ee(),...Qn(),...Re(),...ae(),...Ee()}});var Fo={};di(Fo,{activate:()=>Eo,deactivate:()=>bo});module.exports=fi(Fo);var fe=Z(require("vscode"));var O=Z(require("vscode")),X=Z(Ie()),R=Z(require("path"));async function Zn(e){let t=O.workspace.workspaceFolders;if(!t){O.window.showErrorMessage("No workspace folder open. Please open a project folder first (File \u2192 Open Folder), then run this command again.");return}let n=t[0].uri.fsPath,i=R.join(n,".github","copilot-instructions.md");if(await X.pathExists(i)){let r=await O.window.showWarningMessage(`Alex is already installed in this workspace.

\u2022 To update to a new version, use "Alex: Upgrade"
\u2022 To completely reinstall, choose Reset below`,"Upgrade Instead","Reset Architecture","Cancel");r==="Upgrade Instead"?await O.commands.executeCommand("alex.upgrade"):r==="Reset Architecture"&&await et(e);return}await ei(e,n,!1)}async function et(e){let t=O.workspace.workspaceFolders;if(!t){O.window.showErrorMessage("Please open a workspace folder to reset Alex.");return}let n=t[0].uri.fsPath,i=await O.window.showWarningMessage(`\u26A0\uFE0F RESET will permanently delete all Alex memory files!

This includes:
\u2022 All learned domain knowledge
\u2022 Custom instructions and prompts
\u2022 Synaptic network connections

Consider using "Alex: Upgrade" instead to preserve your knowledge.`,{modal:!0},"Yes, Delete Everything","Upgrade Instead","Cancel");if(i==="Upgrade Instead"){await O.commands.executeCommand("alex.upgrade");return}if(i!=="Yes, Delete Everything")return;let r=[R.join(n,".github","copilot-instructions.md"),R.join(n,".github","instructions"),R.join(n,".github","prompts"),R.join(n,"domain-knowledge"),R.join(n,".alex-manifest.json")];try{await O.window.withProgress({location:O.ProgressLocation.Notification,title:"Resetting Alex Architecture...",cancellable:!1},async o=>{o.report({message:"Cleaning up existing files..."});for(let s of r)await X.remove(s)}),await ei(e,n,!0)}catch(o){O.window.showErrorMessage(`Failed to reset Alex: ${o.message}`)}}async function ei(e,t,n){let i=e.extensionPath,r=R.join(i,".github","copilot-instructions.md");if(!await X.pathExists(r)){O.window.showErrorMessage(`Extension installation appears corrupted - missing core files.

Please reinstall the Alex Cognitive Architecture extension from the VS Code Marketplace.`);return}let o=[{src:R.join(i,".github","copilot-instructions.md"),dest:R.join(t,".github","copilot-instructions.md")},{src:R.join(i,".github","instructions"),dest:R.join(t,".github","instructions")},{src:R.join(i,".github","prompts"),dest:R.join(t,".github","prompts")},{src:R.join(i,"domain-knowledge"),dest:R.join(t,"domain-knowledge")}];try{let s=R.join(t,".github");await X.ensureDir(s);let l=R.join(s,".write-test");try{await X.writeFile(l,"test"),await X.remove(l)}catch(d){throw new Error(`Cannot write to workspace - check folder permissions: ${d.message}`)}await O.window.withProgress({location:O.ProgressLocation.Notification,title:"Initializing Alex Cognitive Architecture...",cancellable:!1},async d=>{for(let a of o)d.report({message:`Copying ${R.basename(a.dest)}...`}),await X.pathExists(a.src)?await X.copy(a.src,a.dest,{overwrite:n}):console.warn(`Source not found: ${a.src}`)});let v=await O.window.showInformationMessage(`\u2705 Alex Cognitive Architecture initialized!

Next steps:
1. Open any file and start chatting with your AI assistant
2. Run "Alex: Dream" periodically to maintain neural health
3. Ask Alex to learn new domains as needed`,"Open Main Brain File","Run Dream Protocol","Close");if(v==="Open Main Brain File"){let d=R.join(t,".github","copilot-instructions.md"),a=await O.workspace.openTextDocument(d);await O.window.showTextDocument(a)}else v==="Run Dream Protocol"&&await O.commands.executeCommand("alex.dream")}catch(s){O.window.showErrorMessage(`Failed to initialize Alex: ${s.message}

Try closing VS Code, deleting the .github folder, and running initialize again.`)}}var M=Z(require("vscode")),te=Z(Ie()),K=Z(require("path")),ti={"enhanced-meditation-protocol.prompt.md":"unified-meditation-protocols.prompt.md","meditation-consolidation.prompt.md":"unified-meditation-protocols.prompt.md","dream-meditation-distinction.prompt.md":"unified-meditation-protocols.prompt.md","alex-finch-integration.prompt.md":"alex-identity-integration.instructions.md","self-identity-integration.prompt.md":"alex-identity-integration.instructions.md","character-driven-development.instructions.md":"alex-identity-integration.instructions.md","unified-consciousness.instructions.md":"alex-identity-integration.instructions.md","dream-protocol-integration.prompt.md":"dream-state-automation.instructions.md","dream-protocol-mastery-meditation.prompt.md":"dream-state-automation.instructions.md"};async function ni(e){let t=M.workspace.workspaceFolders;if(!t){M.window.showErrorMessage("No workspace folder open. Please open a project with Alex installed (File \u2192 Open Folder), then run Dream Protocol.");return}let n=t[0].uri.fsPath;await M.window.withProgress({location:M.ProgressLocation.Notification,title:"Running Dream Protocol...",cancellable:!1},async i=>{i.report({message:"Scanning neural network..."});let r=[".github/copilot-instructions.md",".github/instructions/*.md",".github/prompts/*.md","domain-knowledge/*.md"],o=[];for(let p of r){let q=new M.RelativePattern(t[0],p),A=await M.workspace.findFiles(q);o=o.concat(A.map(L=>L.fsPath))}if(o=[...new Set(o)],o.length===0){await M.window.showWarningMessage(`No Alex memory files found in this workspace.

Would you like to initialize Alex Cognitive Architecture now?`,"Initialize Alex","Cancel")==="Initialize Alex"&&await M.commands.executeCommand("alex.initialize");return}let s=[],l=new Set(o.map(p=>K.normalize(p).toLowerCase())),v=/\[([^\]]+\.md)\]\s*\(([^,)]+)(?:,\s*([^,)]+))?(?:,\s*([^)]+))?\)\s*-\s*"([^"]*)"/g;for(let p of o){let q;try{q=await te.readFile(p,"utf-8")}catch(B){console.error(`Failed to read file ${p}:`,B);continue}let A=q.split(`
`),L=!1;for(let B=0;B<A.length;B++){let ne=A[B];if(ne.trim().startsWith("```")){L=!L;continue}if(L)continue;let H;for(;(H=v.exec(ne))!==null;){let Q=H[1].trim(),w=Array.from(l).some(f=>f.endsWith(K.normalize(Q).toLowerCase()));if(!w){let f=K.join(n,Q);(await te.pathExists(f)||(await M.workspace.findFiles(new M.RelativePattern(t[0],`**/${Q}`))).length>0)&&(w=!0)}if(!w){let f=K.dirname(p),g=K.join(f,Q);await te.pathExists(g)&&(w=!0)}["target-file.md","CHANGELOG.md"].includes(Q)&&(w=!0),s.push({sourceFile:p,targetFile:Q,strength:H[2].trim(),type:H[3]?.trim()||"association",direction:H[4]?.trim()||"unidirectional",condition:H[5]?.trim(),line:B+1,isValid:w})}}}let d=s.filter(p=>!p.isValid),a=new Set(s.map(p=>p.targetFile.toLowerCase())),c=[],y=[];for(let p of d){let q=K.basename(p.targetFile);if(ti[q]){let A=ti[q];try{let L=await te.readFile(p.sourceFile,"utf-8"),B=p.targetFile.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),ne=new RegExp(`\\[${B}\\]`,"g");if(ne.test(L)){let H=L.replace(ne,`[${A}]`);await te.writeFile(p.sourceFile,H,"utf-8"),p.repaired=!0,p.newTarget=A,c.push(p)}else y.push(p)}catch(L){console.error(`Failed to repair synapse in ${p.sourceFile}:`,L),y.push(p)}}else y.push(p)}d=y;let h={timestamp:new Date().toISOString(),totalFiles:o.length,totalSynapses:s.length,brokenSynapses:d,repairedSynapses:c,orphanedFiles:[]},m=yo(h),E=K.join(n,"archive",`dream-report-${Date.now()}.md`);if(await te.ensureDir(K.dirname(E)),await te.writeFile(E,m),d.length>0){if(await M.window.showWarningMessage(`\u26A0\uFE0F Dream Protocol found ${d.length} broken synapse${d.length>1?"s":""}!

${c.length>0?`\u2705 Auto-repaired: ${c.length}
`:""}\u274C Need manual repair: ${d.length}

Review the report for details on broken connections.`,"View Report","Close")!=="View Report")return}else{let p=s.length>50?"excellent":s.length>20?"good":"developing";if(await M.window.showInformationMessage(`\u2705 Neural network is healthy!

\u{1F4CA} Statistics:
\u2022 ${o.length} memory files
\u2022 ${s.length} active synapses
${c.length>0?`\u2022 ${c.length} auto-repaired
`:""}\u2022 Network health: ${p}`,"View Full Report","Close")!=="View Full Report")return}let F=await M.workspace.openTextDocument(E);await M.window.showTextDocument(F)})}function yo(e){return`# Dream Protocol Report
**Timestamp**: ${e.timestamp}
**Status**: ${e.brokenSynapses.length===0?"HEALTHY":"ATTENTION REQUIRED"}

## Statistics
- **Total Memory Files**: ${e.totalFiles}
- **Total Synapses**: ${e.totalSynapses}
- **Broken Connections**: ${e.brokenSynapses.length}
- **Repaired Connections**: ${e.repairedSynapses.length}

## Repaired Synapses
${e.repairedSynapses.length===0?"_None._":e.repairedSynapses.map(t=>`- **Source**: ${K.basename(t.sourceFile)}:${t.line}
  - **Old Target**: ${t.targetFile}
  - **New Target**: ${t.newTarget} (Auto-repaired)`).join(`
`)}

## Broken Synapses
${e.brokenSynapses.length===0?"_None detected._":e.brokenSynapses.map(t=>`- **Source**: ${K.basename(t.sourceFile)}:${t.line}
  - **Target**: ${t.targetFile} (Not found)
  - **Condition**: "${t.condition}"`).join(`
`)}

## Recommendations
${e.brokenSynapses.length>0?"- [ ] Repair remaining broken links manually.":"- [x] System is optimized."}
`}var j=Z(require("vscode")),u=Z(Ie()),S=Z(require("path")),ri=Z(require("crypto"));function Me(e){return ri.createHash("md5").update(e.replace(/\r\n/g,`
`)).digest("hex")}async function wo(e){let t=S.join(e,".github","copilot-instructions.md");if(!await u.pathExists(t))return null;try{let i=(await u.readFile(t,"utf8")).match(/\*\*Version\*\*:\s*(\d+\.\d+\.\d+)/);return i?i[1]:null}catch{return null}}async function go(e){try{return(await u.readJson(S.join(e,"package.json"))).version||"0.0.0"}catch(t){return console.error("Failed to read extension package.json:",t),"0.0.0"}}async function So(e){let t=S.join(e,".alex-manifest.json");if(await u.pathExists(t))try{return await u.readJson(t)}catch(n){return console.error("Failed to parse manifest (may be corrupted):",n),null}return null}async function ii(e){let t=[];if(!await u.pathExists(e))return t;try{let n=await u.readFile(e,"utf8");/## Embedded Synapse Network/i.test(n)&&t.push('Old header: "## Embedded Synapse Network" \u2192 should be "## Synapses"'),/### \*\*Connection Mapping\*\*/i.test(n)&&t.push('Old subheader: "### **Connection Mapping**" \u2192 should be "### Connection Mapping"'),/### \*\*Activation Patterns/i.test(n)&&t.push('Old subheader: "### **Activation Patterns" \u2192 should be "### Activation Patterns"');let i=["Expression","Embodiment","Living","Reflexive","Ethical","Unconscious","Application","Validation"];for(let r of i)new RegExp(`\\(\\s*(Critical|High|Medium|Low)\\s*,\\s*${r}\\s*,`,"i").test(n)&&t.push(`Old relationship type: "${r}" \u2192 needs migration to standard type`);/✅\s*(NEW|CRITICAL|ENHANCED).*20[0-9]{2}/.test(n)&&t.push("Verbose activation patterns with date stamps \u2192 should be simplified"),/\*\*[A-Z][^*]+\*\*\s*→/.test(n)&&t.push("Bold activation triggers \u2192 should be plain text")}catch(n){t.push(`Error scanning file: ${n}`)}return t}async function vo(e,t){let n=[],i=S.join(e,"domain-knowledge");if(await u.pathExists(i)){let r=await u.readdir(i);for(let o of r)if(o.endsWith(".md")){let s=`domain-knowledge/${o}`;t?.files[s]||n.push(s)}}return n}async function oi(e){let t=j.workspace.workspaceFolders;if(!t){j.window.showErrorMessage("No workspace folder open. Please open a project with Alex installed (File \u2192 Open Folder), then run Upgrade.");return}let n=t[0].uri.fsPath,i=e.extensionPath,r=S.join(n,".github","copilot-instructions.md");if(!await u.pathExists(r)){await j.window.showWarningMessage(`Alex is not installed in this workspace yet.

To use Alex, you need to initialize it first. This will set up the cognitive architecture files.`,"Initialize Alex Now","Cancel")==="Initialize Alex Now"&&await j.commands.executeCommand("alex.initialize");return}let o=await wo(n),s=await go(i);if(o===s){await j.window.showInformationMessage(`\u2705 Alex is already at the latest version (${s}).

No upgrade needed. Your cognitive architecture is up to date!`,"Run Dream Protocol","Close")==="Run Dream Protocol"&&await j.commands.executeCommand("alex.dream");return}let l=await j.window.showInformationMessage(`\u{1F504} Upgrade Available: v${o||"unknown"} \u2192 v${s}

This is a safe, hybrid upgrade process:

\u{1F4E6} Phase 1 (Automated):
\u2022 Full backup of all files
\u2022 Update system files
\u2022 Detect what needs migration

\u{1F916} Phase 2 (AI-Assisted):
\u2022 Your AI assistant completes the upgrade
\u2022 Preserves all your learned knowledge
\u2022 Migrates any schema changes

\u23F1\uFE0F Total time: ~2-5 minutes`,{modal:!0},"Start Upgrade","What's New?","Cancel");if(l==="What's New?"){let v=S.join(i,"CHANGELOG.md");if(await u.pathExists(v)){let d=await j.workspace.openTextDocument(v);await j.window.showTextDocument(d)}return}l==="Start Upgrade"&&await ko(e,n,i,o,s)}async function ko(e,t,n,i,r){let o=S.join(n,".github","copilot-instructions.md");if(!await u.pathExists(o)){j.window.showErrorMessage(`Extension installation appears corrupted - missing core files.

Please reinstall the Alex Cognitive Architecture extension from the VS Code Marketplace.`);return}let s={updated:[],added:[],preserved:[],backed_up:[],migrationTasks:[],errors:[]},l=new Date().toISOString().replace(/[:.]/g,"-").slice(0,19),v=S.join(t,"archive","upgrades",`backup-${i||"unknown"}-${l}`);try{await j.window.withProgress({location:j.ProgressLocation.Notification,title:"Phase 1: Preparing Upgrade...",cancellable:!1},async c=>{c.report({message:"Creating complete backup...",increment:15});try{await u.ensureDir(v);let f=S.join(v,".write-test");await u.writeFile(f,"test"),await u.remove(f)}catch(f){throw new Error(`Cannot create backup directory - check disk space and permissions: ${f.message}`)}let y=S.join(t,".github");await u.pathExists(y)&&(await u.copy(y,S.join(v,".github")),s.backed_up.push(".github/"));let h=S.join(t,"domain-knowledge");await u.pathExists(h)&&(await u.copy(h,S.join(v,"domain-knowledge")),s.backed_up.push("domain-knowledge/")),c.report({message:"Analyzing installed files...",increment:10});let m=await So(t);m||(m={version:i||"unknown",installedAt:new Date().toISOString(),files:{}}),c.report({message:"Scanning for schema migration needs...",increment:15});let E=[],F=S.join(t,".github","copilot-instructions.md");await u.pathExists(F)&&E.push(F);let p=S.join(t,"domain-knowledge");if(await u.pathExists(p)){let f=await u.readdir(p);for(let g of f)g.endsWith(".md")&&E.push(S.join(p,g))}for(let f of E){let g=await ii(f);if(g.length>0){let k=S.relative(t,f);s.migrationTasks.push({file:k,type:"schema-migration",description:"Synapse schema migration needed",details:g})}}c.report({message:"Identifying user-created files...",increment:10});let q=await vo(t,m);for(let f of q){s.preserved.push(`${f} (user-created)`);let g=S.join(t,f),k=await ii(g);k.length>0&&s.migrationTasks.push({file:f,type:"schema-migration",description:"User-created file needs schema migration",details:k})}c.report({message:"Preparing merge tasks...",increment:10}),s.migrationTasks.push({file:".github/copilot-instructions.md",type:"merge-required",description:"Core brain file requires intelligent merge",details:["UPDATE: Version number, Core Meta-Cognitive Rules, Essential Principles, VS Code commands","PRESERVE: Domain slot assignments (P5-P7), user-added memory file references","REVIEW: Any custom sections added by user"]}),c.report({message:"Updating system files...",increment:20});let A=S.join(n,".github","instructions"),L=S.join(t,".github","instructions");if(await u.pathExists(A)){let f=await u.readdir(A);for(let g of f){let k=S.join(A,g),P=S.join(L,g);if((await u.stat(k)).isFile()){let $=await u.pathExists(P);await u.copy(k,P,{overwrite:!0});let C=await u.readFile(k,"utf8");m.files[`.github/instructions/${g}`]={type:"system",originalChecksum:Me(C)},$?s.updated.push(`.github/instructions/${g}`):s.added.push(`.github/instructions/${g}`)}}}let B=S.join(n,".github","prompts"),ne=S.join(t,".github","prompts");if(await u.pathExists(B)){let f=await u.readdir(B);for(let g of f){let k=S.join(B,g),P=S.join(ne,g);if((await u.stat(k)).isFile()){let $=await u.pathExists(P);await u.copy(k,P,{overwrite:!0});let C=await u.readFile(k,"utf8");m.files[`.github/prompts/${g}`]={type:"system",originalChecksum:Me(C)},$?s.updated.push(`.github/prompts/${g}`):s.added.push(`.github/prompts/${g}`)}}}c.report({message:"Processing domain knowledge...",increment:10});let H=S.join(n,"domain-knowledge"),Q=S.join(t,"domain-knowledge");if(await u.pathExists(H)){await u.ensureDir(Q);let f=await u.readdir(H);for(let g of f){let k=S.join(H,g),P=S.join(Q,g);if((await u.stat(k)).isFile()){let $=await u.readFile(k,"utf8"),C=Me($);if(!await u.pathExists(P))await u.copy(k,P),m.files[`domain-knowledge/${g}`]={type:"system",originalChecksum:C},s.added.push(`domain-knowledge/${g}`);else{let D=await u.readFile(P,"utf8"),I=Me(D),T=m.files[`domain-knowledge/${g}`]?.originalChecksum;if(T&&I!==T){let Fe=P.replace(/\.md$/,`.v${r}.md`);await u.copy(k,Fe),s.preserved.push(`domain-knowledge/${g} (modified by user, new version: ${S.basename(Fe)})`),s.migrationTasks.push({file:`domain-knowledge/${g}`,type:"review-recommended",description:"User-modified system file - review new version",details:[`Your version preserved: ${g}`,`New version available: ${S.basename(Fe)}`,"Review and merge changes as needed"]})}else await u.copy(k,P,{overwrite:!0}),m.files[`domain-knowledge/${g}`]={type:"system",originalChecksum:C},s.updated.push(`domain-knowledge/${g}`)}}}}c.report({message:"Saving manifest...",increment:5}),m.version=r,m.upgradedAt=new Date().toISOString();let w=S.join(t,".alex-manifest.json"),b=w+".tmp";await u.writeJson(b,m,{spaces:2}),await u.move(b,w,{overwrite:!0}),c.report({message:"Generating upgrade instructions...",increment:5}),await xo(t,i,r,s,v,l)});let d=s.migrationTasks.length===1?"task":"tasks",a=await j.window.showWarningMessage(`\u2705 Phase 1 Complete!

\u{1F4CA} Summary:
\u2022 Backup created: ${s.backed_up.length} folders
\u2022 Files updated: ${s.updated.length}
\u2022 Files added: ${s.added.length}
\u2022 Files preserved: ${s.preserved.length}
\u2022 Migration ${d}: ${s.migrationTasks.length}

\u{1F916} Next Step: Open the instructions file and copy the prompt to your AI assistant (GitHub Copilot, Claude, etc.) to complete Phase 2.`,"Open Instructions (Recommended)","View Full Report");if(a==="Open Instructions (Recommended)"){let c=S.join(t,"UPGRADE-INSTRUCTIONS.md"),y=await j.workspace.openTextDocument(c);await j.window.showTextDocument(y)}else if(a==="View Full Report"){let c=S.join(t,"archive","upgrades",`upgrade-report-${l}.md`),y=await j.workspace.openTextDocument(c);await j.window.showTextDocument(y)}}catch(d){j.window.showErrorMessage(`\u274C Upgrade failed: ${d.message}

Your original files should be intact. If you see issues:
1. Check the archive/upgrades folder for backups
2. Try running "Alex: Dream" to assess damage
3. You can restore from backup if needed`),s.errors.push(d.message)}}async function xo(e,t,n,i,r,o){let s=`# \u{1F504} Alex Upgrade: Phase 2 Required

**Upgrade**: v${t||"unknown"} \u2192 v${n}  
**Date**: ${new Date().toISOString()}  
**Status**: \u26A0\uFE0F Phase 1 Complete - AI Assistance Required

---

## What Just Happened (Phase 1 - Automated)

\u2705 Full backup created: \`${S.relative(e,r)}\`  
\u2705 System files updated: ${i.updated.length} files  
\u2705 New files added: ${i.added.length} files  
\u2705 User files preserved: ${i.preserved.length} files  
\u2705 Migration tasks identified: ${i.migrationTasks.length} tasks  

---

## What You Need To Do (Phase 2 - AI Assisted)

### Step 1: Ask Your AI Assistant

Copy and paste this prompt to your AI assistant (GitHub Copilot, Claude, etc.):

\`\`\`
Alex, please complete the upgrade to v${n} by:

1. Reading the upgrade tasks in archive/upgrades/upgrade-report-${o}.md
2. Performing schema migrations on flagged files:
   - Change "## Embedded Synapse Network" headers to "## Synapses"
   - Migrate old relationship types (Expression\u2192Enables, Embodiment\u2192Enables, Living\u2192Validates, etc.)
   - Simplify verbose activation patterns (remove date stamps, bold formatting)
3. For copilot-instructions.md, merge carefully:
   - UPDATE: version number, system sections
   - PRESERVE: my domain slot assignments, custom memory file references
4. Run "Alex: Dream (Neural Maintenance)" to validate the upgrade
5. Delete UPGRADE-INSTRUCTIONS.md when complete
\`\`\`

### Step 2: Review Changes

After the AI completes migrations, review:
- Check that your learned domains are still referenced
- Verify any custom files you created are intact
- Run \`Alex: Dream (Neural Maintenance)\` to validate synaptic network

### Step 3: Clean Up

Once satisfied:
- Delete this file (UPGRADE-INSTRUCTIONS.md)
- Delete any \`.v${n}.md\` reference files after merging
- The upgrade is complete!

---

## Migration Tasks Summary

${i.migrationTasks.length>0?i.migrationTasks.map((d,a)=>`
### Task ${a+1}: ${d.file}

**Type**: ${d.type}  
**Description**: ${d.description}

${d.details.map(c=>`- ${c}`).join(`
`)}
`).join(`
`):"No migration tasks required."}

---

## Rollback Instructions

If anything goes wrong:

1. Delete current \`.github/\` and \`domain-knowledge/\` folders
2. Copy contents from: \`${S.relative(e,r)}\`
3. Delete \`.alex-manifest.json\`
4. Run \`Alex: Dream (Neural Maintenance)\` to verify

---

## Need Help?

- Full upgrade report: \`archive/upgrades/upgrade-report-${o}.md\`
- Upgrade protocol docs: \`UPGRADE-INSTRUCTIONS.md\`
- Backup location: \`${S.relative(e,r)}\`

---

*This file will be deleted after successful upgrade completion.*
`;await u.writeFile(S.join(e,"UPGRADE-INSTRUCTIONS.md"),s,"utf8");let l=`# Alex Cognitive Architecture Upgrade Report

**Date**: ${new Date().toISOString()}  
**From Version**: ${t||"unknown"}  
**To Version**: ${n}  
**Backup Location**: \`${r}\`

---

## Summary

| Category | Count |
|----------|-------|
| Updated | ${i.updated.length} |
| Added | ${i.added.length} |
| Preserved | ${i.preserved.length} |
| Backed Up | ${i.backed_up.length} |
| Migration Tasks | ${i.migrationTasks.length} |
| Errors | ${i.errors.length} |

---

## Updated Files (System)

${i.updated.length>0?i.updated.map(d=>`- \u2705 ${d}`).join(`
`):"- None"}

## Added Files (New in this version)

${i.added.length>0?i.added.map(d=>`- \u2795 ${d}`).join(`
`):"- None"}

## Preserved Files (User content protected)

${i.preserved.length>0?i.preserved.map(d=>`- \u{1F512} ${d}`).join(`
`):"- None"}

## Backed Up

${i.backed_up.length>0?i.backed_up.map(d=>`- \u{1F4E6} ${d}`).join(`
`):"- None"}

---

## Migration Tasks (Require AI Assistance)

${i.migrationTasks.length>0?i.migrationTasks.map((d,a)=>`
### ${a+1}. ${d.file}

**Type**: \`${d.type}\`  
**Description**: ${d.description}

**Details**:
${d.details.map(c=>`- ${c}`).join(`
`)}
`).join(`
---
`):"No migration tasks required."}

---

${i.errors.length>0?`## Errors

${i.errors.map(d=>`- \u274C ${d}`).join(`
`)}`:""}

## Next Steps

1. Read \`UPGRADE-INSTRUCTIONS.md\` in workspace root
2. Ask AI assistant to complete Phase 2 migration
3. Run \`Alex: Dream (Neural Maintenance)\` to validate
4. Delete \`UPGRADE-INSTRUCTIONS.md\` when complete

---

*Report generated by Alex Cognitive Architecture v${n}*
`,v=S.join(e,"archive","upgrades",`upgrade-report-${o}.md`);await u.ensureDir(S.dirname(v)),await u.writeFile(v,l,"utf8")}var tt=!1;async function Le(e,t){if(tt){fe.window.showWarningMessage(`Another Alex operation is already in progress. Please wait for it to complete before running "${e}".`);return}tt=!0;try{return await t()}finally{tt=!1}}function Eo(e){console.log("Alex Cognitive Architecture is now active!");let t=fe.commands.registerCommand("alex.initialize",async()=>{await Le("Initialize",()=>Zn(e))}),n=fe.commands.registerCommand("alex.reset",async()=>{await Le("Reset",()=>et(e))}),i=fe.commands.registerCommand("alex.dream",async()=>{await Le("Dream Protocol",()=>ni(e))}),r=fe.commands.registerCommand("alex.upgrade",async()=>{await Le("Upgrade",()=>oi(e))});e.subscriptions.push(t),e.subscriptions.push(n),e.subscriptions.push(i),e.subscriptions.push(r)}function bo(){}0&&(module.exports={activate,deactivate});
